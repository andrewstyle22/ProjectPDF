@{
    ViewBag.Title = "About";
}
<!--http://usefulangle.com/post/20/pdfjs-tutorial-1-preview-pdf-during-upload-wih-next-prev-buttons-->
<button id="upload-button">Select PDF</button>
<input type="file" id="file-to-upload" accept="application/pdf" />
<div id="controlpdf" style="text-align: center;visibility: hidden;">
	<button id="prevbutton" type="button">prev page</button>
	<button id="nextbutton" type="button">next page</button>
	<!--<button id="zoominbutton" type="button">zoom in</button>
	<button id="zoomoutbutton" type="button">zoom out</button>-->
	<button id="cmd">Save PDF</button>
</div>
<div style="text-align: center;margin-top:10px;" id="page-count-container">
	Page <div id="pdf-current-page"></div> of <div id="pdf-total-pages"></div>
</div>
<div class="colorButtons" style="text-align: center;margin-top: 17px;margin-bottom: 10px;font-weight: bolder;">
  <h3>Colour</h3>
  <input type="color" id="colorpicker" value="#000000" class="colorpicker">
</div>
  <!--<input type="file" id="selectPDF" ="openPDF" accept="application/pdf" />-->
<div id="buttonTool" style="text-align: center">
	<button type="button" value="clear" id="clr" size="23" onclick="erase()">Clear</button>
	<br />
	<br />
	<div id="loading" style="font-size: x-large;">Loading page ...</div>
	<canvas id="the-canvas" style="border: 1px solid black;padding-bottom: 1px;"></canvas>
</div>

<script>
  let arrayImageData = [];

  let __PDF_DOC,
    __CURRENT_PAGE,
    __TOTAL_PAGES,
    __PAGE_RENDERING_IN_PROGRESS = 0,
    __CANVAS = $('#the-canvas').get(0),
    __CANVAS_CTX = __CANVAS.getContext('2d');

  function showPDF(pdf_url) {
    $("#the-canvas").show();

    PDFJS.getDocument({ url: pdf_url }).then(async function (pdf_doc) {
      __PDF_DOC = pdf_doc;
      __TOTAL_PAGES = __PDF_DOC.numPages;
      // Hide the pdf loader and show pdf container in HTML
      $("#the-canvas").hide();
      $("#controlpdf").show();
      $("#pdf-total-pages").text(__TOTAL_PAGES);

			for(var x = 1;x <= __TOTAL_PAGES; x++) {
				var data = { numPage: x, dataImage: ''};
				arrayImageData.push(data);
			}

      // Show the first page
      for(let x=1;x <= __TOTAL_PAGES;x++){
        await showPage(x);
      }
			console.log(arrayImageData);
      showPage(1);
			$("#the-canvas, #controlpdf").css("visibility", "visible");
			init();
			// $("#controlpdf").css("visibility", "visible");
    }).catch(function (error) {
      // If error re-show the upload button
      $("#the-canvas, #controlpdf").hide();
			// $("#controlpdf").hide();
      $("#upload-button").show();

      alert(error.message);
    });;
  }

  async function showPage(page_no) {
    __PAGE_RENDERING_IN_PROGRESS = 1;
    __CURRENT_PAGE = page_no;

    // Disable Prev & Next buttons while page is being loaded
    $("#nextbutton, #prevbutton").attr('disabled', 'disabled');

    // While page is being rendered hide the canvas and show a loading message
    $("#the-canvas").hide();
    $("#loading").show();

    // Update current page in HTML
    $("#pdf-current-page").text(page_no);

    // Fetch the page
    await __PDF_DOC.getPage(page_no).then(async function (page) {
      // As the canvas is of a fixed width we need to set the scale of the viewport accordingly
      const scale_required = __CANVAS.width / page.getViewport(1).width;

      // Get viewport of the page at required scale
      //var viewport = page.getViewport(scale_required);
			const viewport = page.getViewport(1);
      // Set canvas height
      __CANVAS.height = viewport.height;
      __CANVAS.width  = viewport.width;

      var renderContext = {
        canvasContext: __CANVAS_CTX,
        viewport: viewport
      };

      // Render the page contents in the canvas
      await page.render(renderContext).then(function () {
        __PAGE_RENDERING_IN_PROGRESS = 0;
				arrayImageData[page_no - 1].dataImage = __CANVAS.toDataURL("image/jpeg", 1.0);
        // Re-enable Prev & Next buttons
        $("#nextbutton, #prevbutton").removeAttr('disabled');

        // Show the canvas and hide the page loader
        $("#the-canvas").show();
        $("#loading").hide();
      });
    });
  }


  // Upon click this should should trigger click on the #file-to-upload file input element
  // This is better than showing the not-good-looking file input element
  $("#upload-button").on('click', function () {
    $("#file-to-upload").trigger('click');
  });

  // When user chooses a PDF file
  $("#file-to-upload").on('change', function () {
		if($("#file-to-upload").get(0).files[0] !== undefined) {
			// Validate whether PDF
			if (['application/pdf'].indexOf($("#file-to-upload").get(0).files[0].type) == -1) {
				alert('Error : Not a PDF');
				return;
			}

			//$("#upload-button").hide();

			// Send the object url of the pdf
			showPDF(URL.createObjectURL($("#file-to-upload").get(0).files[0]));
		}
  });

  // Previous page of the PDF
  $("#prevbutton").on('click', async function () {
    if (__CURRENT_PAGE != 1) {
			arrayImageData[__CURRENT_PAGE - 1].dataImage = __CANVAS.toDataURL("image/jpeg", 1.0);
			--__CURRENT_PAGE;
			document.getElementById("the-canvas").src = await loadImage();
			$("#pdf-current-page").text(__CURRENT_PAGE);
      //showPage(--__CURRENT_PAGE);
		}
  });

  // Next page of the PDF
  $("#nextbutton").on('click', async function () {
    if (__CURRENT_PAGE != __TOTAL_PAGES) {
			arrayImageData[__CURRENT_PAGE - 1].dataImage = __CANVAS.toDataURL("image/jpeg", 1.0);
			++__CURRENT_PAGE;
			document.getElementById("the-canvas").src = await loadImage();
			$("#pdf-current-page").text(__CURRENT_PAGE);
      //showPage(++__CURRENT_PAGE);
		}
  });

	async function loadImage() {
		let imagen = new Image();
		if (arrayImageData[__CURRENT_PAGE - 1].dataImage.length > 0) {
			imagen.src = arrayImageData[__CURRENT_PAGE - 1].dataImage;
		} else {
			imagen.src = URL.createObjectURL($("#file-to-upload").get(0).files[0]);
		}
		imagen.onload = function () {
			canvas = document.getElementById('the-canvas');
			drawContext = canvas.getContext('2d');
			canvas.width = imagen.width;
			canvas.height = imagen.height;
			drawContext.scale(1, 1);
			drawContext.save();
			drawContext.drawImage(imagen, 0, 0);
		};
		return imagen.src;
	}

	function erase() {
		const canvasErase = document.getElementById('the-canvas');
		const contextErase = canvasErase.getContext('2d');
		//var m = confirm("Want to clear");
		//if (m) {
			contextErase.clearRect(0, 0, canvasErase.width, canvasErase.height);
			document.getElementById('the-canvas').value = "";
			$('#file-to-upload').val('');
			$("#controlpdf").css('visibility', 'hidden');
		//}
	}

	/////// save PDF  \\\\\\\\
	$('#cmd').click(async function () {
		$("#df-buttons").children().prop('disabled',true);
		arrayImageData[__CURRENT_PAGE - 1].dataImage = __CANVAS.toDataURL("image/jpeg", 1.0);
		console.log('__CURRENT_PAGE: ', __CURRENT_PAGE);
		console.log(__CANVAS.width, __CANVAS.height);
		let orientation = (__CANVAS.width > __CANVAS.height) ? 'l': 'p';
		let pdf = new jsPDF(orientation, 'mm', [__CANVAS.width , __CANVAS.height]);
		for (let x=0;x < __TOTAL_PAGES;x++) {
			const imgData = arrayImageData[x].dataImage;
			pdf.setPage(x+1);//declare that we're working on that page
			pdf.addImage(imgData, 'jpeg', 0, 0, __CANVAS.width, __CANVAS.height);
			(__TOTAL_PAGES - 1 !== x ) ? pdf.addPage(): '';
		}
		$("#df-buttons").children().prop('disabled',false);
		await pdf.save("download.pdf"); 
	});

	/////// Draw Canvas  \\\\\\\\
	var isMouseDown=false;
	var canvas;//document.getElementById("the-canvas");
	var ctx;//canvas.getContext('2d');
	var linesArray = [];
	currentSize = 1;
	var currentColor = "rgb(0,0,0)";
	var currentBg = "white";
	var drawing = false;
	var mousePos = {x:0, y:0};
	var lastPos = mousePos;
	let isMobile = false; 

	function isSurface() {
		const isWindows = navigator.userAgent.indexOf('Windows') > -1;
		const maxTouchPoints = navigator.maxTouchPoints || navigator.msMaxTouchPoints;
		const isTouchable = 'ontouchstart' in window
			|| maxTouchPoints > 0
			|| window.matchMedia && matchMedia('(any-pointer: coarse)').matches;
		return isWindows && isTouchable;
	}
	let userAgent = navigator.userAgent || navigator.vendor || window.opera;
	if ( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|windows phone|Opera Mini/i.test(navigator.userAgent) || isSurface()) {
	/*if (/windows phone/i.test(userAgent) ||
			/Android/i.test(userAgent) || 
			/iPad|iPhone|iPod/.test(userAgent) ||
			('ontouchstart' in window) || 
			window.DocumentTouch && document instanceof DocumentTouch) {*/
			isMobile = true;
	}
	

	// Prevent scrolling when touching the canvas
	document.body.addEventListener("touchstart", function (e) {
		if (e.target == canvas) {
			e.preventDefault();
		}
	}, false);
	document.body.addEventListener("touchend", function (e) {
		if (e.target == canvas) {
			e.preventDefault();
		}
	}, false);
	document.body.addEventListener("touchmove", function (e) {
		if (e.target == canvas) {
			e.preventDefault();
		}
	}, false);

	function init() {
		canvas = __CANVAS; //document.getElementById('the-canvas');
		ctx = __CANVAS_CTX; //canvas.getContext("2d");
		w = __CANVAS.width;//widthCanvas;
		h = __CANVAS.height;//heightCanvas;
		document.getElementById('colorpicker').addEventListener('change', function() {
			currentColor = this.value;
		});
		// mouse/touch events ..
		canvas.addEventListener((isMobile ? 'touchstart' : 'mousedown'), function() {mousedown(canvas, event);});
		canvas.addEventListener((isMobile ? 'touchmove' : 'mousemove'), function() {mousemove(canvas, event);});
		canvas.addEventListener((isMobile ? 'touchend' : 'mouseup'), mouseup);
		/*
		canvas.addEventListener('mousedown', function() {mousedown(canvas, event);});
		canvas.addEventListener('mousemove',function() {mousemove(canvas, event);});
		canvas.addEventListener('mouseup',mouseup);
		*/
	}

	// GET MOUSE POSITION
  function getMousePos(canvas, touchOrMouseEvent) {
    var rect = canvas.getBoundingClientRect();
		return {
			x: (isMobile ? touchOrMouseEvent.touches[0].clientX : touchOrMouseEvent.clientX) - rect.left,
			y: (isMobile ? touchOrMouseEvent.touches[0].clientY : touchOrMouseEvent.clientY) - rect.top
		};
    /*return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };*/
  }

	function getTouchPos(canvasDom, touchEvent) {
		var rect = canvasDom.getBoundingClientRect();
		return {
			x: touchEvent.touches[0].clientX - rect.left,
			y: touchEvent.touches[0].clientY - rect.top
		};
	}

  // ON MOUSE DOWN
  function mousedown(canvas, evt) {
    //var mousePos = getMousePos(canvas, evt);
    isMouseDown=true
    var currentPosition = getMousePos(canvas, evt);
    ctx.moveTo(currentPosition.x, currentPosition.y)
    ctx.beginPath();
    ctx.lineWidth  = currentSize;
    ctx.lineCap = "round";
    ctx.strokeStyle = currentColor;
  }

  // ON MOUSE MOVE
  function mousemove(canvas, evt) {
    if(isMouseDown){
      var currentPosition = getMousePos(canvas, evt);
      ctx.lineTo(currentPosition.x, currentPosition.y)
      ctx.stroke();
      //store(currentPosition.x, currentPosition.y, currentSize, currentColor);
    }
  }

  function mouseup() {
    isMouseDown=false
    //store()
  }

</script>